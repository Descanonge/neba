"""Writer module: write data to disk."""

from __future__ import annotations

import inspect
import json
import logging
import os
import socket
import subprocess
from collections.abc import Callable, Iterable, Mapping, Sequence
from datetime import datetime
from os import path
from typing import (
    TYPE_CHECKING,
    Any,
    Generic,
    Protocol,
    TypeVar,
    cast,
    overload,
    runtime_checkable,
)

from traitlets import Bool, Int, List, Unicode

from neba.config import Section
from neba.config.loaders.json import JsonEncoderTypes
from neba.utils import get_classname

from .module import Module
from .types import T_Data, T_Source, T_Source_contra

if TYPE_CHECKING:
    from .interface import DataInterface


log = logging.getLogger(__name__)


class MetadataElement:
    """Generate one or more metadata items.

    Parameters
    ----------
    func
        Method of :class:`MetadataGenerator` that is called to generate items. It
        returns either a single item (if simple) or a mapping of multiple items.
    items
        List of items names generated by this element. If left to None, the element is
        considered "simple": it generates a single item of the same name as the element.
    name_mapping
        Mapping to rename items (``{"item_name": "new_name"}``). Items names must be
        registered (via `items` for multiple items).
    """

    def __init__(
        self,
        func: Callable[[MetadataGenerator], Any],
        items: list[str] | None = None,
        name_mapping: Mapping[str, str] | None = None,
    ) -> None:
        self.func = func
        self.name = func.__name__
        self.simple = items is None

        if items is None:
            items = [self.name]
        self.items = items

        self.name_mapping: dict[str, str] = {}
        if name_mapping is not None:
            self.rename(**name_mapping)

    def generate(self, gen: MetadataGenerator) -> None:
        """Populate the metadata attribute of the generator."""
        try:
            items = self.func(gen)
        except Exception as exc:
            log.warning("Failed to run metadata element '%s' (%s)", self.name, exc)
            return

        if items is None:
            return

        if self.simple:
            items = {self.func.__name__: items}

        renamed = {}
        for name, elt in items.items():
            if name in self.name_mapping:
                name = self.name_mapping[name]
            renamed[name] = elt

        gen.metadata.update(renamed)

    def rename(self, name: str | None = None, **kwargs: str) -> None:
        """Rename item(s).

        Parameters
        ----------
        name
            If the element is simple, rename to that.
        kwargs
            Rename multiple items.
        """
        if name is not None:
            if not self.simple:
                raise TypeError(
                    "Metadata element is not simple, cannot rename "
                    f"with single argument `name` ({name})"
                )
            self.name_mapping[self.name] = name

        for name, new_name in kwargs.items():
            if name not in self.items:
                raise KeyError(
                    f"Target '{name}' for renaming is not in registered items "
                    f"({self.items})"
                )
            self.name_mapping[name] = new_name


@overload
def element(
    function: Callable[[MetadataGenerator], Any],
    *,
    elements: list[str] | None = ...,
    name_mapping: Mapping[str, str] | None = None,
) -> MetadataElement: ...


@overload
def element(
    function: None = ...,
    *,
    elements: list[str] | None = ...,
    name_mapping: Mapping[str, str] | None = None,
) -> Callable[[Callable], MetadataElement]: ...


def element(
    function: Callable[[MetadataGenerator], Any] | None = None,
    *,
    elements: list[str] | None = None,
    name_mapping: Mapping[str, str] | None = None,
) -> Callable[[Callable], MetadataElement] | MetadataElement:
    """Decorator that turns methods into metadata elements.

    Can be used as ``@element`` or ``@element(elements=..., ...)``.

    Parameters
    ----------
    function
        Takes a :class:`.MetadataGenerator` instance and return either a single value
        (that will be given the same name as the method) or a mapping of multiple items.
    elements
        If the method return a mapping of multiple items, specify their names.
    name_mapping
        Mapping to rename items (``{"item_name": "new_name"}``).
    """  # noqa: D401

    def decorator(f: Callable) -> MetadataElement:
        elt = MetadataElement(f, items=elements, name_mapping=name_mapping)
        elt.__doc__ = f.__doc__
        return elt

    if function is not None:
        return decorator(function)
    return decorator


class MetadataOptions(Section):
    """Options for metadata generator."""

    elements = List(
        Unicode(),
        allow_none=True,
        default_value=None,
        help="Manually specify elements to run. If left to None, all elements are run.",
    )

    elements_to_skip = {
        "add_params": ["creation_params"],
        "add_git_info": ["creation_commit", "creation_diff"],
    }
    """Mapping of trait options to lists of elements to skip if that option is False."""

    add_params = Bool(True, help="If True add parameters (either as dict or str).")
    add_git_info = Bool(
        True, help="If True add information about git repository status."
    )

    # -- Other parameters --

    params_exclude = List(
        Unicode(),
        default_value=["log_"],
        help="Prefixes of parameters to exclude from metadata attribute.",
    )
    params_str = Bool(True, help="If True, serialize parameters using JSON.")

    max_diff_lines = Int(30, help="Maximum number of lines to include in diff.")

    creation_script = Unicode(
        None,
        allow_none=True,
        help="Manually specify the creation script.",
    )

    git_ignore = List(
        Unicode(),
        default_value=[],
        help="Files and folders to ignore when creating git diff.",
    )


class MetadataGenerator:
    """Generate metadata from interface.

    Options are stored in an instance of :attr:`options_cls`.


    Parameters
    ----------
    di
        The parent DataInterface.
    kwargs
        Options passed to :attr:`options_cls`.
    """

    options_cls = MetadataOptions

    def __init__(self, di: DataInterface, **kwargs: Any) -> None:
        self.di: DataInterface = di
        self.metadata: dict[str, Any] = {}
        """Dictionary that is progressively filled during generation."""
        self.options = self.options_cls(**kwargs)

        self.elements: dict[str, MetadataElement] = {}
        for basetype in self.__class__.mro():
            for key, value in basetype.__dict__.items():
                if isinstance(value, MetadataElement):
                    self.elements[key] = value

    def get_elements(self) -> list[str]:
        """Return element, skipping those not selected by user."""
        elements = self.options.elements
        if elements is None:
            elements = self.elements.keys()

        elements_to_skip = []
        for selector_option, to_skip in self.options.elements_to_skip.items():
            if not getattr(self.options, selector_option):
                elements_to_skip += to_skip

        return [elt for elt in elements if elt not in elements_to_skip]

    def generate(self) -> dict[str, Any]:
        """Generate metadata."""
        for name in self.get_elements():
            if (element := self.elements.get(name, None)) is None:
                raise AttributeError(f"No metadata element named '{name}'")

            element.generate(self)

        self.postprocess()

        return self.metadata

    def postprocess(self) -> None:
        """Modify the metadata attribute in place, after generation."""
        pass

    @element
    def written_with_interface(self) -> str:
        """Class-name and ID of parent interface."""
        cls_name = get_classname(self.di)
        if self.di.ID:
            cls_name += f":{self.di.ID}"
        return cls_name

    @element
    def creation_time(self) -> str:
        """Date and time."""
        return datetime.today().strftime("%x %X")

    @element
    def creation_hostname(self) -> str:
        """Return hostname of current running process."""
        return socket.gethostname()

    @element
    def creation_script(self) -> str:
        """Filename of top-level script or notebook."""
        if self.options.creation_script is not None:
            return self.options.creation_script

        # check if in Jupyter session
        try:
            import IPython
        except ImportError:
            pass
        else:
            ip = IPython.get_ipython()
            if (
                ip is not None
                and (session := ip.user_ns.get("__session__")) is not None
                and session.endswith(".ipynb")  # could be a console
            ):
                return session

        script = None
        for stack in inspect.stack():
            # we can still be in a IPython console
            if "IPython" in stack.filename:
                break
            script = stack.filename

        if script is None:
            raise ValueError

        return script

    @element
    def creation_params(self) -> dict[str, Any] | str:
        """Return interface parameters as dictionary or str."""
        # This should work for dict and Section, but not necessarily for future
        # parameters containers
        params = dict(self.di.parameters.direct)
        for prefix in self.options.params_exclude:
            params = {k: v for k, v in params.items() if not k.startswith(prefix)}

        if not self.options.params_str:
            return params

        return json.dumps(params, cls=JsonEncoderTypes)

    @element
    def creation_commit(self) -> str:
        """Return latest commit hash.

        Use the `creation_script` if present in metadata, or ``"."`` otherwise.
        """
        # use the directory of the calling script
        gitdir = path.dirname(self.metadata.get("creation_script", "."))

        cmd = ["git", "-C", gitdir, "rev-parse", "HEAD"]
        ret = subprocess.run(cmd, capture_output=True, text=True, check=True)
        return ret.stdout.strip()

    @element(elements=["creation_diff_short", "creation_diff_long"])
    def creation_diff(self) -> dict[str, Any] | None:
        """Add git diff, only if latest commit hash is present.

        * ``creation_diff_short``: list of files modified since last commit
        * ``creation_diff_long``: full diff, truncated at
          :attr:`~.MetadataOptions.max_diff_lines`

        Use the `creation_script` if present in metadata, or ``"."`` otherwise.
        """
        if "creation_commit" not in self.metadata:
            return None

        metadata = {}

        def git_cmd(cmd: list[str]) -> str:
            """Execute git command with informative log message."""
            ret = subprocess.run(cmd, capture_output=True, text=True, check=False)
            if ret.returncode != 0:
                err = ret.stderr.strip()
                if (stop := err.find("usage:")) > 0:
                    err = err[:stop]
                msg = f"Error in creating git diff with command {' '.join(cmd)}\n{err}"
                log.warning(msg)
                raise RuntimeError
            return ret.stdout.strip()

        # use the directory of the calling script
        gitdir = path.dirname(self.metadata.get("creation_script", "."))

        # get top level (necessary for exclude arguments)
        gitdir = git_cmd(["git", "-C", gitdir, "rev-parse", "--show-toplevel"])

        # check if there is diff
        diffcmd = [
            "git",
            "-C",
            gitdir,
            "--no-pager",
            "diff",
            "-w",
            "--diff-filter=M",
            "--minimal",
        ]
        exclude_cmd = [f":!{x}" for x in self.options.git_ignore]

        stat = git_cmd(diffcmd + ["--numstat"] + exclude_cmd)
        if stat:
            stat_lines = []
            for line in stat.splitlines():
                plus, minus, filename = line.split("\t")
                stat_lines.append(f"{filename}:+{plus}:-{minus}")
            metadata["creation_diff_short"] = stat_lines

            # add full diff
            diff = git_cmd(diffcmd + ["--unified=0"] + exclude_cmd).splitlines()
            if (n := len(diff)) > (m := self.options.max_diff_lines):
                diff = diff[:m]
                diff.append(f"... {n - m} additional lines")
            metadata["creation_diff_long"] = diff

        return metadata


class WriterAbstract(Generic[T_Source_contra, T_Data], Module):
    """Abstract class of Writer module."""

    metadata_generator = MetadataGenerator

    def get_metadata(self, **kwargs: Any) -> dict[str, Any]:
        """Get information on how data was created.

        Uses :attr:`metadata_generator`.

        Parameters
        ----------
        kwargs
            Options passed to :class:`MetadataOptions`
        """
        generator = self.metadata_generator(self.di, **kwargs)
        return generator.generate()

    def write(
        self,
        data: T_Data | Sequence[T_Data],
        target: T_Source_contra | Sequence[T_Source_contra] | None = None,
        metadata_kwargs: Mapping[str, Any] | None = None,
        **kwargs: Any,
    ) -> Any:
        """Write data to file or store.

        :Not implemented: implement in a module subclass.

        Parameters
        ----------
        data
            Data to write.
        target
            If None, target location(s) should be obtained via
            :meth:`.DataInterface.get_source`.
        metadata_kwargs
            Passed to the :attr:`metadata_generator`. See :class:`.MetadataOptions` for
            available options.
        kwargs
            Passed to the writing function.
        """
        raise NotImplementedError("Implement in a module subclass.")

    def check_directories(
        self, calls: Sequence[tuple[T_Source_contra, T_Data]]
    ) -> None:
        """Check if directories are missing, and create them if necessary."""
        files = [f for f, _ in calls]

        # Keep only the containing directories, with no duplicate
        directories = set()
        for f in files:
            directories.add(path.dirname(cast(str | os.PathLike, f)))

        for d in directories:
            if not path.isdir(d):
                log.debug("Creating output directory %s", d)
                os.makedirs(d)

    def check_directory(self, call: tuple[T_Source_contra, T_Data]) -> None:
        """Check if directory is missing, and create it if necessary."""
        self.check_directories([call])

    def check_overwriting_calls(
        self, calls: Sequence[tuple[T_Source_contra, T_Data]]
    ) -> None:
        """Check if some calls have the same filename."""
        outfiles = [f for f, _ in calls]
        duplicates = []
        for f in set(outfiles):
            if outfiles.count(f) > 1:
                duplicates.append(f)

        if duplicates:
            raise ValueError(
                f"Multiple writing calls to the same filenameÂ·s: {duplicates}"
            )

    def send_single_call(
        self, call: tuple[T_Source_contra, T_Data], **kwargs: Any
    ) -> Any:
        """Execute a single call.

        :Not implemented: implement in a module subclass.

        Parameters
        ----------
        kwargs
            Passed to the writing function.
        """
        raise NotImplementedError("Implement in a module subclass.")

    def send_calls(
        self, calls: Sequence[tuple[T_Source_contra, T_Data]], **kwargs: Any
    ) -> list[Any]:
        """Send multiple calls serially.

        Check beforehand if there are filename conflicts betwen calls, and make
        sure the necessary (sub)directories are created if they not exist already.

        Parameters
        ----------
        kwargs
            Passed to writing function.
        """
        self.check_overwriting_calls(calls)
        self.check_directories(calls)

        return [self.send_single_call(call, **kwargs) for call in calls]


T = TypeVar("T", covariant=True)


@runtime_checkable
class Splitable(Protocol[T]):
    """Protocol for a source module that can split data into multiple sources.

    A number of parameters can be left :meth:`unfixed` which results in multiple files
    (for instance, if we do not "fix" the parameter *year*, we can have files for any
    year we want).

    It must also implement a :meth:`get_filename` method that returns a filename when
    given a specific set of values.

    The idea is that a module can split data according to the parameters that are left
    unfixed (example by year), once the data is split we find the associated filename
    for each year and we then write to files.

    The protocol is generic and allows for any type of source.
    """

    @property
    def unfixed(self) -> Iterable[T]:
        """Iterable of parameters that are not fixed.

        This must take into account the values that are specified (or not) in the
        data-manager parameters.
        """

    def get_filename(self, **fixes: Any) -> T:
        """Return a filename corresponding to this set of values.

        This must also take into account values that are already specified in the
        data-manager parameters (that are not present in the *fixes* argument).
        """


class SplitWriterMixin(WriterAbstract[T_Source, T_Data]):
    """Split data to multiple writing targets.

    For that, we need to have an appropriate Source module that adheres to the
    :class:`Splitable` protocol. This mixin checks this. It makes available the
    necessary methods directly to the Writer module.
    """

    source: Splitable[T_Source]

    def setup(self) -> None:
        """Set up module. Check the source is following the Splitable protocol."""
        super().setup()

        if not isinstance(self.di.source, Splitable):
            raise TypeError(f"Source module is not Splitable ({type(self.di)})")
        self.source = self.di.source

    def unfixed(self) -> set[T_Source]:
        """Return set of parameters that are not fixed."""
        return set(self.source.unfixed)

    def get_filename(self, **kwargs: Any) -> T_Source:
        """Return a filename corresponding to current parameters and kwargs."""
        return self.source.get_filename(**kwargs)
